package jdbcwrapper.txmonitoring;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import jdbcwrapper.WrappedConnection;
import jdbcwrapper.measurement.MeasuringConnection;
import jdbcwrapper.measurement.MeasuringPreparedStatement;
import jdbcwrapper.measurement.MeasuringStatement;

public abstract class AbstractTxMonitoringConnection<L extends TransactionListener> extends WrappedConnection<L> implements MeasuringConnection, TxMonitoringConnection {

	public AbstractTxMonitoringConnection(final Connection wrappedConnection, final List<L> listeners) {
		super(wrappedConnection, listeners);
	}

	@Override
	public void setAutoCommit(final boolean enable) throws SQLException {
		super.setAutoCommit(enable);

		if (!enable) {
			this.onTransactionStart();
		}
	}

	protected Statement wrapStatement(final Statement statement) {
		return new MeasuringStatement(statement, this);
	}

	protected PreparedStatement wrapPreparedStatement(final PreparedStatement statement) {
		return new MeasuringPreparedStatement(statement, this);
	}

	@Override
	public Statement createStatement() throws SQLException {
		return this.wrapStatement(super.createStatement());
	}

	@Override
	public Statement createStatement(final int resultSetType, final int resultSetConcurrency) throws SQLException {
		return this.wrapStatement(super.createStatement(resultSetType, resultSetConcurrency));
	}

	@Override
	public Statement createStatement(final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability) throws SQLException {
		return this.wrapStatement(super.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability));
	}

	@Override
	public PreparedStatement prepareStatement(final String sql) throws SQLException {
		return this.wrapPreparedStatement(super.prepareStatement(sql));
	}

	@Override
	public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
		return this.wrapPreparedStatement(super.prepareStatement(sql, autoGeneratedKeys));
	}

	@Override
	public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency)
			throws SQLException {
		return this.wrapPreparedStatement(super.prepareStatement(sql, resultSetType, resultSetConcurrency));
	}

	@Override
	public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability) throws SQLException {
		return this.wrapPreparedStatement(
				super.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
	}

	@Override
	public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
		return this.wrapPreparedStatement(super.prepareStatement(sql, columnIndexes));
	}

	@Override
	public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
		return this.wrapPreparedStatement(super.prepareStatement(sql, columnNames));
	}

	@Override
	public void commit() throws SQLException {
		this.onTransactionEnd(true);
		super.commit();
	}

	@Override
	public void rollback() throws SQLException {
		this.onTransactionEnd(false);
		super.rollback();
	}

	protected void onTransactionStart() {
		this.notifyConnectionListeners(listener -> listener.onTransactionStart(this));
	}

	protected void onTransactionEnd(final boolean success) {
		this.notifyConnectionListeners(listener -> listener.onTransactionEnd(this, success));
	}

	@Override
	public void onStatementStart(final Statement statement) {
		// Do nothing by default
	}

	@Override
	public void onStatementEnd(final Statement statement) {
		// Do nothing by default
	}
	
}
